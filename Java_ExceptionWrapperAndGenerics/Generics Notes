1. What Are Generics?

Generics let you create classes, interfaces, and methods
that work with different data types while maintaining type safety.

Without generics, you‚Äôd often have to cast objects manually, which is error-prone.
Generics allow the compiler to check types at compile time, preventing many runtime errors.

*******************************************************************************************

Example: Without Generics
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        ArrayList list = new ArrayList();
        list.add("Hello");
        list.add(123); // Works, but risky!

        String text = (String) list.get(0); // Needs casting
        System.out.println(text);
    }
}


Here, you could accidentally add a wrong type (like an Integer) ‚Äî which could cause a runtime error later.

üíª Example: With Generics
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        ArrayList<String> words = new ArrayList<>();
        words.add("Hello");
        // words.add(123);  // ‚ùå Compile-time error!

        String text = words.get(0);  // No casting needed
        System.out.println(text);
    }
}

‚úÖ Safer, cleaner, and easier to maintain!



<T> type parameter (placeholder that gets replaced with a real type).

*** Explanation of Generics Exe ***
1. Creating a Generic Class (Box<T>)
class Box <T>: The <T> right after the class name signifies that Box is a generic class.
T is a Type Parameter, a placeholder that will be replaced by a real type (like String or Double) when the class is instantiated.

T item;: The item field is declared to be of type T.
This means the box can hold an item of any single type.

public void setItem(T item) and public T getItem():
The getter and setter methods use the type parameter T, ensuring type safety for all interactions with the item.

2. Using the Generic Class in Main
The main method shows how you bind the Type Parameter T to a specific type:

Box<String> box = new Box<>();: Here,
T is replaced by String. The compiler now knows this specific box can only hold String objects.

box.setItem("Doll"); is valid.

box.setItem(123); would be a compile-time error.

Box<Double> box1 = new Box<>();: Here, T is replaced by Double.
This box1 can only hold Double objects.

box1.setItem(4.5); is valid.
This clearly illustrates how generics provide type safety and
allow you to reuse the same class logic (Box) for multiple types without casting or code duplication.

üí¨ 1. Why is using generics safer than using raw types (non-generic collections)?

Because generics allow compile-time type checking, preventing type errors before the program runs.
In raw types, you can accidentally add incompatible data (like mixing String and Integer),
which can cause runtime exceptions.
Generics ensure that a collection only contains one specific type ‚Äî improving safety, readability, and reliability.

üí¨ 2. How does the compiler help enforce type safety when you use generics?

The compiler verifies that every item added to or retrieved from a generic collection matches the specified type parameter.
For example, if you declare ArrayList<String>, the compiler blocks adding integers or other objects ‚Äî
preventing invalid operations before the code runs.

üí¨ 3. Can you think of a real-world example where a method should work with multiple data types?

Yes! A data container, logger, or utility function can work with multiple data types.
Example:
A printBox(T item) method could accept String, Integer, or Double
‚Äî making the code reusable for any data type without rewriting the logic for each.